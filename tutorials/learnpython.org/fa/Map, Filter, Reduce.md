آموزش
--------
Map، Filter و Reduce الگوهایی از برنامه‌نویسی تابعی هستند. آن‌ها به برنامه‌نویس امکان می‌دهند کدی ساده‌تر و کوتاه‌تر بنویسد بدون آنکه الزاماً به جزئیات حلقه‌ها و شرط‌ها پرداخته شود.

این سه تابع به شما اجازه می‌دهند تابعی را روی یک یا چند iterable اعمال کنید. `map` و `filter` در پایتون داخلی هستند و نیازی به وارد کردن ندارند. اما `reduce` در ماژول `functools` قرار دارد و باید وارد شود. بیایید با `map` شروع کنیم.

#### Map
تابع `map()` در پایتون به شکل زیر است:

```map(func, *iterables)```

که در آن `func` تابعی است که روی هر یک از عناصر `iterables` اعمال می‌شود. علامت ستاره (`*`) نشان می‌دهد که می‌توان چندین iterable داشت. توجه کنید تابع باید همان تعداد آرگومان را بپذیرد که تعداد iterableها است.

نکات مهم:
1. در پایتون 2، `map()` یک لیست برمی‌گرداند. در پایتون 3، `map()` یک شیء map (تولیدکننده) برمی‌گرداند. برای گرفتن لیست باید `list()` روی آن فراخوانی کنید.
2. تعداد آرگومان‌های `func` باید برابر با تعداد iterableها باشد.

بیایید ببینیم این قوانین چگونه در مثال‌های زیر اعمال می‌شوند.

فرض کنید یک لیست از نام‌های حیوانات خانگی مورد علاقه‌ام دارم که همه به حروف کوچک هستند و نیاز دارم که به حروف بزرگ تبدیل شوند. به طور سنتی، در پایتون معمولی، چیزی شبیه به این انجام می‌دادم:

    my_pets = ['alfred', 'tabitha', 'william', 'arla']
    uppered_pets = []

    for pet in my_pets:
        pet_ = pet.upper()
        uppered_pets.append(pet_)

    print(uppered_pets)

که خروجی آن خواهد بود ```['ALFRED', 'TABITHA', 'WILLIAM', 'ARLA']```

با استفاده از تابع ```map()```، این کار نه تنها آسان‌تر است، بلکه انعطاف‌پذیری بیشتری نیز دارد. من به سادگی این کار را انجام می‌دهم:

    # Python 3
    my_pets = ['alfred', 'tabitha', 'william', 'arla']

    uppered_pets = list(map(str.upper, my_pets))

    print(uppered_pets)

که همچنین همان نتیجه را می‌دهد. توجه داشته باشید که با توجه به نحو تعریف شده ```map()```، در اینجا ```func``` برابر با ```str.upper``` است و ```iterables``` لیست ```my_pets``` است -- فقط یک iterable. همچنین توجه داشته باشید که ما تابع ```str.upper``` را فراخوانی نکردیم (این کار: ```str.upper()```)، زیرا تابع map این کار را برای ما روی _هر عنصر در لیست ```my_pets```_ انجام می‌دهد.

نکته مهم‌تر این است که تابع ```str.upper``` به طور پیش‌فرض فقط به **یک** آرگومان نیاز دارد و بنابراین ما فقط **یک** iterable به آن دادیم. بنابراین، _اگر تابعی که شما ارسال می‌کنید به دو، یا سه، یا n آرگومان نیاز دارد_، _پس شما نیز باید به همان تعداد (دو، سه یا n) iterable به آن بدهید_. بیایید این را با یک مثال دیگر روشن کنیم.

فرض کنید یک لیست از مساحت‌های دایره دارم که جایی محاسبه کرده‌ام، همه با پنج رقم اعشار. و نیاز دارم که هر عنصر در لیست را به تعداد اعشار موقعیت خود گرد کنم، به این معنی که باید اولین عنصر لیست را به یک رقم اعشار، دومین عنصر را به دو رقم اعشار، سومین عنصر را به سه رقم اعشار و الی آخر گرد کنم. با استفاده از ```map()``` این کار بسیار آسان است. بیایید ببینیم چگونه است.

پایتون به ما تابع داخلی ```round()``` را می‌دهد که به دو آرگومان نیاز دارد -- عددی که باید گرد شود و تعداد اعشار که باید عدد به آن گرد شود. بنابراین، از آنجا که تابع به **دو** آرگومان نیاز دارد، ما نیز باید **دو** iterable به آن بدهیم.

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 7)))

    print(result)

زیبایی ```map()``` را ببینید؟ آیا می‌توانید تصور کنید که این چقدر انعطاف‌پذیر است؟

تابع ```range(1, 7)``` به عنوان آرگومان دوم به تابع ```round``` عمل می‌کند (تعداد اعشار مورد نیاز در هر تکرار). بنابراین همانطور که ```map``` در حال تکرار در ```circle_areas``` است، در اولین تکرار، اولین عنصر ```circle_areas```، ```3.56773``` به همراه اولین عنصر ```range(1,7)```، ```1``` به ```round``` منتقل می‌شود، به طوری که به طور مؤثر به ```round(3.56773, 1)``` تبدیل می‌شود. در دومین تکرار، دومین عنصر ```circle_areas```، ```5.57668``` به همراه دومین عنصر ```range(1,7)```، ```2``` به ```round``` منتقل می‌شود و آن را به ```round(5.57668, 2)``` تبدیل می‌کند. این روند تا رسیدن به انتهای لیست ```circle_areas``` ادامه می‌یابد.

مطمئنم که شما در حال حاضر می‌پرسید: "اگر یک iterable با طول کمتر یا بیشتر از طول اولین iterable ارسال کنم چه؟ یعنی، اگر ```range(1, 3)``` یا ```range(1, 9999)``` را به عنوان دومین iterable در تابع بالا ارسال کنم چه اتفاقی می‌افتد". و پاسخ ساده است: هیچ‌چیز! خوب، این درست نیست. "هیچ‌چیز" از آن جهت است که تابع ```map()``` هیچ استثنایی را ایجاد نخواهد کرد، بلکه به سادگی تا زمانی که نتواند یک آرگومان دوم برای تابع پیدا کند، به تکرار عناصر ادامه می‌دهد، در این نقطه به سادگی متوقف شده و نتیجه را برمی‌گرداند.

بنابراین، به عنوان مثال، اگر شما ```result = list(map(round, circle_areas, range(1, 3)))``` را ارزیابی کنید، هیچ خطایی دریافت نخواهید کرد حتی اگر طول ```circle_areas``` و طول ```range(1, 3)``` متفاوت باشد. در عوض، این است که پایتون انجام می‌دهد: اولین عنصر ```circle_areas``` و اولین عنصر ```range(1,3)``` را می‌گیرد و آن‌ها را به ```round``` می‌فرستد. ```round``` آن را ارزیابی کرده و نتیجه را ذخیره می‌کند. سپس به تکرار دوم می‌رود، دومین عنصر ```circle_areas``` و دومین عنصر ```range(1,3)``` را می‌گیرد و آن‌ها را به ```round``` می‌فرستد و دوباره نتیجه را ذخیره می‌کند. حالا، در تکرار سوم (```circle_areas``` دارای یک عنصر سوم است)، پایتون عنصر سوم ```circle_areas``` را می‌گیرد و سپس سعی می‌کند عنصر سوم ```range(1,3)``` را بگیرد اما از آنجا که ```range(1,3)``` دارای یک عنصر سوم نیست، پایتون به سادگی متوقف شده و نتیجه را برمی‌گرداند، که در این مورد به سادگی ```[3.6, 5.58]``` خواهد بود. 

ادامه دهید، امتحان کنید.

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 3)))

    print(result)


همین اتفاق می‌افتد اگر ```circle_areas``` کمتر از طول دومین iterable باشد. پایتون به سادگی زمانی متوقف می‌شود که نتواند عنصر بعدی را در یکی از iterableها پیدا کند. 

برای تثبیت دانش خود از تابع ```map()```، ما قصد داریم از آن برای پیاده‌سازی تابع ```zip()``` خودمان استفاده کنیم. تابع ```zip()``` تابعی است که تعدادی iterable را می‌گیرد و سپس یک تاپل حاوی هر یک از عناصر در iterableها را ایجاد می‌کند. مانند ```map()```, در پایتون 3، یک شیء تولیدکننده برمی‌گرداند، که می‌توان به راحتی با فراخوانی تابع داخلی ```list``` بر روی آن به لیست تبدیل کرد. از جلسه مفسر زیر برای درک بهتر ```zip()``` قبل از ایجاد آن با ```map()``` استفاده کنید

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(zip(my_strings, my_numbers))
    
    print(results)

به عنوان یک پاداش، آیا می‌توانید حدس بزنید در جلسه بالا چه اتفاقی می‌افتد اگر ```my_strings``` و ```my_numbers``` از نظر طول برابر نباشند؟ نه؟ امتحان کنید! طول یکی از آن‌ها را تغییر دهید.

به سراغ تابع ```zip()``` سفارشی خودمان برویم!

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(map(lambda x, y: (x, y), my_strings, my_numbers))

    print(results)

فقط به این نگاه کنید! ما همان نتیجه را به عنوان ```zip``` داریم. 

آیا همچنین متوجه شدید که حتی نیازی به ایجاد یک تابع با استفاده از روش استاندارد ```def my_function()``` ندارم؟ اینقدر انعطاف‌پذیر است ```map()```، و به طور کلی پایتون! من به سادگی از یک تابع ```lambda``` استفاده کردم. این به این معنا نیست که استفاده از روش تعریف تابع استاندارد (با ```def function_name()```) مجاز نیست، هنوز هم مجاز است. من فقط ترجیح دادم کد کمتری بنویسم (به طور "پایتونیک").

این تمام چیزی است که درباره map باید بدانید. به سراغ ```filter()``` برویم.

#### Filter
در حالی که ```map()``` هر عنصر در iterable را از طریق یک تابع عبور می‌دهد و نتیجه را از همه عناصری که از طریق تابع عبور کرده‌اند برمی‌گرداند، ```filter()```، اول از همه، نیاز دارد که تابع مقادیر بولی (درست یا نادرست) برگرداند و سپس هر عنصر در iterable را از طریق تابع عبور می‌دهد و آن‌هایی را که نادرست هستند "فیلتر" می‌کند. این تابع دارای نحو زیر است:

```filter(func, iterable)```

نکات زیر در مورد ```filter()``` باید توجه شود:

1. بر خلاف ```map()```, فقط یک iterable مورد نیاز است.
2. آرگومان ```func``` نیاز به بازگشت یک نوع بولی دارد. اگر این کار را نکند، ```filter``` به سادگی ```iterable``` را که به آن داده شده است برمی‌گرداند. همچنین، از آنجا که فقط یک iterable مورد نیاز است، به طور ضمنی اینگونه است که ```func``` باید فقط یک آرگومان بپذیرد.
3. ```filter``` هر عنصر در iterable را از طریق ```func``` عبور می‌دهد و فقط آن‌هایی را که به درستی ارزیابی می‌شوند برمی‌گرداند. منظورم این است که، این دقیقاً در نام آن است -- یک "فیلتر".

بیایید چند مثال ببینیم

لیست زیر (```iterable```) نمرات 10 دانش‌آموز در یک امتحان شیمی است. بیایید آن‌هایی را که با نمرات بالای 75 قبول شده‌اند فیلتر کنیم...با استفاده از ```filter```.

    # Python 3
    scores = [66, 90, 68, 59, 76, 60, 88, 74, 81, 65]

    def is_A_student(score):
        return score > 75

    over_75 = list(filter(is_A_student, scores))

    print(over_75)

مثال بعدی یک تشخیص‌دهنده پالینروم خواهد بود. یک "پالینروم" کلمه، عبارت یا دنباله‌ای است که به صورت معکوس همانند جلوخوانی می‌شود. بیایید کلماتی را که پالینروم هستند از یک تاپل (```iterable```) از کلمات مشکوک فیلتر کنیم.

    # Python 3
    dromes = ("demigod", "rewire", "madam", "freer", "anutforajaroftuna", "kiosk")

    palindromes = list(filter(lambda word: word == word[::-1], dromes))

    print(palindromes)

که باید ```['madam', 'anutforajaroftuna']``` را خروجی دهد. 

زیبا نیست؟ بالاخره، ```reduce()```

#### Reduce
```reduce``` یک تابع **با دو آرگومان** را به طور تجمعی به عناصر یک iterable اعمال می‌کند، به طور اختیاری با یک آرگومان اولیه شروع می‌شود. این تابع دارای نحو زیر است:

```reduce(func, iterable[, initial])```

که در آن ```func``` تابعی است که هر عنصر در ```iterable``` به طور تجمعی به آن اعمال می‌شود، و ```initial``` مقداری اختیاری است که قبل از عناصر iterable در محاسبه قرار می‌گیرد و زمانی که iterable خالی است به عنوان پیش‌فرض استفاده می‌شود. نکات زیر در مورد ```reduce()``` باید توجه شود:
1. ```func``` به دو آرگومان نیاز دارد، که اولی آن عنصر اول در ```iterable``` (اگر ```initial``` تامین نشود) و دومی عنصر دوم در ```iterable``` است. اگر ```initial``` تامین شود، آنگاه این مقدار به عنوان اولین آرگومان به ```func``` داده می‌شود و اولین عنصر در ```iterable``` به عنوان دومین عنصر در نظر گرفته می‌شود.
2. ```reduce``` ```iterable``` را به یک مقدار واحد "کاهش" می‌دهد. 

همانطور که معمول است، بیایید چند مثال ببینیم.

بیایید نسخه خودمان از تابع داخلی ```sum()``` پایتون را ایجاد کنیم. تابع ```sum()``` مجموع تمام اقلام در iterable داده شده را برمی‌گرداند.


    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers)
    print(result)


نتیجه، همانطور که انتظار دارید، ```68``` است.

پس، چه اتفاقی افتاد؟

همانطور که معمول است، همه چیز در مورد تکرار است: ```reduce``` اولین و دومین عناصر را در ```numbers``` می‌گیرد و آن‌ها را به ترتیب به ```custom_sum``` می‌فرستد. ```custom_sum``` مجموع آن‌ها را محاسبه کرده و به ```reduce``` برمی‌گرداند. ```reduce``` سپس آن نتیجه را به عنوان اولین عنصر به ```custom_sum``` می‌فرستد و عنصر بعدی (سوم) در ```numbers``` را به عنوان دومین عنصر به ```custom_sum``` می‌فرستد. این کار به طور مداوم (تجمعی) تا زمانی که ```numbers``` تمام شود ادامه می‌یابد. 

بیایید ببینیم وقتی از آرگومان اختیاری ```initial``` استفاده می‌کنم چه اتفاقی می‌افتد.


    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers, 10)
    print(result)


نتیجه، همانطور که انتظار دارید، ```78``` است زیرا ```reduce``` به طور اولیه از ```10``` به عنوان اولین آرگومان به ```custom_sum``` استفاده می‌کند.


این تمام چیزی است که درباره Map، Reduce و Filter در پایتون باید بدانید. سعی کنید تمرینات زیر را برای اطمینان از درک خود از هر تابع انجام دهید.

تمرین
--------
در این تمرین، از هر یک از ```map```، ```filter``` و ```reduce``` برای اصلاح کد خراب استفاده خواهید کرد. 

کد آموزشی
-------------
from functools import reduce 

# Use map to print the square of each numbers rounded
# to three decimal places
my_floats = [4.35, 6.09, 3.25, 9.77, 2.16, 8.88, 4.59]

# Use filter to print only the names that are less than 
# or equal to seven letters
my_names = ["olumide", "akinremi", "josiah", "temidayo", "omoseun"]

# Use reduce to print the product of these numbers
my_numbers = [4, 6, 9, 23, 5]

# Fix all three respectively.
map_result = list(map(lambda x: x, my_floats))
filter_result = list(filter(lambda name: name, my_names, my_names))
reduce_result = reduce(lambda num1, num2: num1 * num2, my_numbers, 0)

print(map_result)
print(filter_result)
print(reduce_result)

خروجی مورد انتظار
---------------
test_output_contains("[18.922, 37.088, 10.562, 95.453, 4.666, 78.854, 21.068]")
test_output_contains("['olumide', 'josiah', 'omoseun']")
test_output_contains("24840")
success_msg("Congrats! Nice work.")

راه حل
--------
#### Map
from functools import reduce 

my_floats = [4.35, 6.09, 3.25, 9.77, 2.16, 8.88, 4.59]
my_names = ["olumide", "akinremi", "josiah", "temidayo", "omoseun"]
my_numbers = [4, 6, 9, 23, 5]

map_result = list(map(lambda x: round(x ** 2, 3), my_floats))
filter_result = list(filter(lambda name: len(name) <= 7, my_names))
reduce_result = reduce(lambda num1, num2: num1 * num2, my_numbers)

print(map_result)
print(filter_result)
print(reduce_result)
