
Tutorial
--------
خەرىتە ، سۈزگۈچ ۋە ئازايتىش فۇنكىسىيەلىرى بولسا پروگرامما تۈزۈشنىڭ ئۈلگىسى. ئۇلار پروگراممېر (سىز) نىڭ تېخىمۇ ئاددىي ، قىسقا كود يېزىشىغا يول قويىدۇ.  ھالقا ۋە شاخلىنىش قاتارلىق ئىنچىكە ھالقىلارنى ئىشلىتىشىڭىزنىڭ ھاجىتى يوق.


ماھىيەتتە ، بۇ ئۈچ فۇنكىسىيەلەر سىزنىڭ بىر فۇنكىسىيە بىلەنلا بىر نەچچە تەكرارلانمىلارنى ئىشلىتىشىڭىزگە يول قۇيىدۇ. "خەرىتە" ۋە "سۈزگۈچ" Python بىلەن بىللە قاچىلانغان بۇلۇپ ("__builtins__" مودۇلىدا) ، ئىمپورت قىلىشنى تەلەپ قىلمايدۇ. ئازايتىش ، ئەمما فۇنكسىيە مودۇلىدا بولغاچقا ئىمپورت قىلىشقا توغرا كېلىدۇ. «خەرىتە» دىن باشلاپ ، ئۇلارنىڭ ھەممىسىنىڭ قانداق ئىشلەيدىغانلىقىنى تېخىمۇ ياخشى چۈشىنىۋالايلى.

#### خەرىتە
Python دىكى `` ()map ``  فۇنكسىيەسىنىڭ تۆۋەندىكى گرامماتىكىسى بار:

```map(func, *iterables)```

بۇ يەردە `` func``` بولسا `` itebles`` دىكى ھەر بىر ئېلېمېنتنىڭ ئىشلىتىلىشى. `` Iterbles`` دىكى يۇلتۇز بەلگىسى (`` `` ``) غا دىققەت قىلىڭ؟ ئۇنىڭ مەنىسى ئىمكانقەدەر كۆپ تەكرارلانغىلى بولىدىغانلىقىدىن دېرەك بېرىدۇ ، ھازىرغا قەدەر «فۇنكسىيە» تەلەپ قىلىنغان كىرگۈزۈش ئۆزگەرگۈچى مىقدرلىرىدەك ئېنىق سانغا ئىگە. بىر مىسالغا ئۆتۈشتىن بۇرۇن ، تۆۋەندىكىلەرگە دىققەت قىلىشىڭىز كېرەك:

1. Python 2 دە ، `` ()map `` فۇنكسىيە بىر تىزىملىكنى قايتۇرىدۇ. Python 3 دە ، بۇ ئىقتىدار ياسىغۇچى ئوبيېكتى بولغان «خەرىتە ئوبيېكتى» نى قايتۇرىدۇ. نەتىجىنى تىزىملىك ​​سۈپىتىدە ئېلىش ئۈچۈن ، `()list`` فۇنكسىيەسىنى خەرىتە ئوبيېكتىغا چاقىرىشقا بولىدۇ. يەنى `` تىزىملىك ​​(خەرىتە (فۇنكسىيە ، * تەكرارلاش)) ``
2. «فۇنكسىيە» گە مۇناسىۋەتلىك ئۆزگەرگۈچى مىقدارلارنىڭ سانى چوقۇم «قايتىلانما» نىڭ سانىغا تەڭ بولۇشى كېرەك.

تۆۋەندىكى مىساللار بىلەن بۇ قائىدىلەرنىڭ قانداق رول ئوينايدىغانلىقىنى كۆرۈپ باقايلى.

مېنىڭ ئەڭ ياخشى كۆرىدىغان ئەرمەك ھايۋانلىرىمنىڭ تىزىملىكى بار (`` iterable```) ،خەتلەرنىڭ ھەممىسى كىچىك يېزىلغان ، ئەمما مەن ئۇلارنى چوڭ ھەرپتە يېزىشىم لازىم. كىلاسسىك ئۇسۇلدا ، نورمال پايسوندا، مەن مۇنداق بىر ئىشنى قىلاتتىم:

    my_pets = ['alfred', 'tabitha', 'william', 'arla']
    uppered_pets = []

    for pet in my_pets:
        pet_ = pet.upper()
        uppered_pets.append(pet_)

    print(uppered_pets)

مۇنداق نەتىجە چىقاتتى: ```['ALFRED', 'TABITHA', 'WILLIAM', 'ARLA']```

``()map`` فۇنكسىيەسى بىلەن ، بۇ ئاسان بولۇپلا قالماي ، يەنە تېخىمۇ جانلىق. مەن پەقەت مۇنداق قىلىمەن:

    # Python 3
    my_pets = ['alfred', 'tabitha', 'william', 'arla']

    uppered_pets = list(map(str.upper, my_pets))

    print(uppered_pets)

بۇمۇ ئوخشاش نەتىجىنى چىقىرىدۇ. شۇنىڭغا دىققەت قىلىڭكى ، يۇقىرىدا ئېنىقلانغان «()map» گرامماتىكىسىنى ئىشلەتكەندە ، «func» بۇ ئەھۋالدا «str.upper» ۋە «قايتىشچانلىقى» بولسا «my_pets» تىزىملىكى - پەقەت بىرلا تەكرارلانما. شۇنىڭغا دىققەت قىلىڭكى ، بىز «str.upper» فۇنكىسىيەسىنى (بۇنى قىلىش: `` str.upper () ``) دەپ ئاتىمىدۇق ، چۈنكى خەرىتە ئىقتىدارى بىزگە «my_pets» تىزىملىكىدىكى ھەر بىر ئېلېمېنتنى بېرىدۇ.

دىققەت قىلىشقا تىگىشلىك بولغىنى شۇكى ، `` str.upper``` فۇنكسىيەسى پەقەت ** بىر ** ئۆزگەرگۈچى مىقدار تەلەپ قىلىدۇ ، شۇڭا بىز ئۇنىڭغا پەقەت ** بىر ** تەكرارلانما بەردۇق. شۇڭا ، _ ئەگەر سىز يەتكۈزىدىغان فۇنكىسىيە ئىككى ياكى ئۈچ ياكى n كىرگۈزۈش مىقدارى تەلەپ قىلسا ، ئۇنداقتا _ سىز ئۇنىڭغا ئىككى ، ئۈچ ياكى n تەكرارلاشتا ئۆتۈشىڭىز كېرەك.

مەن بىر يەردە ھېسابلىغان چەمبەر رايونىنىڭ تىزىملىكى بار ، ھەممىسى ئونلۇق كەسىر چىكىتىدىن كىيىنكى بەش خانىدە. ھەمدە مەن تىزىملىكتىكى ھەر بىر ئېلېمېنتنى ئۇنىڭ ئونلۇق ئورنىغا توغرىلىشىم كېرەك ، يەنى مەن تىزىملىكتىكى بىرىنچى ئېلېمېنتنى ئون خانىلىق ئورۇنغا ، تىزىملىكتىكى ئىككىنچى ئېلېمېنتنى يۈز خانىلىق ئورۇنغا ، تىزىملىكتىكى ئۈچىنچى ئېلېمېنتنى مىڭ خانىلىق ئورۇنغا ئايلاندۇرۇشىم كېرەك. بىز ``()map``` نى ئىشلەتسەك، بۇ بەك ئاسان. كۆرۈپ باقايلى:

Python ئاللىبۇرۇن بىزگە ``()round `` `فۇنكسىيەسىنى بەرگەن بۇلۇپ ئۇ ئىككى كىرگۈزگۈچى مىقدارنى ئۆز ئىچىگە ئالىدۇ. چۈنكى ، بۇ فۇنكىسىيە ** ئىككى ** كىرگۈزگۈچى مىقدار تەلەپ قىلىدىغان بولغاچقا ، بىز ** ئىككى ** تەكرارلاشى بېرىپ ئۆتۈشىمىز كېرەك.

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 7)))

    print(result)

"()map" نىڭ گۈزەللىكىنى كۆرۈڭ؟ بۇنىڭ ئىشلىتىشنىڭ جانلىقلىقىنى تەسەۋۋۇر قىلالامسىز؟

«range(1, 7)» فۇنكىسىيەسى «round» فۇنكىسىيەسىنىڭ ئىككىنچى پارامېتىرىلىق (ھەر بىر قېتىملىق تەكرارلاشتا كېرەكلىك ئۆنچكە سانلار سانى) رولىنى ئۆتەيدۇ. شۇڭا map فۇنكىسىيەسى «circle_areas» تىزىمىدىن ئۆتكەندە، تۇنجى قېتىملىق تەكرارلاش ۋاقتىدا «circle_areas» تىزىمىنىڭ تۇنجى ئېلېمېنتى «3.56773» ۋە «range(1,7)» نىڭ تۇنجى ئېلېمېنتى «1» نى «round» فۇنكىسىيەسىگە يوللىنىدۇ، بۇنىڭ بىلەن ئۇ ئەمەلىيەتتە «round(3.56773, 1)» بولىدۇ.

1)```. ئىككىنچى قېتىملىق تەكرارلاش ۋاقتىدا، «`circle_areas`» تىزىمىنىڭ ئىككىنچى ئېلېمېنتى «`5.57668`» ۋە «`range(1,7)`» نىڭ ئىككىنچى ئېلېمېنتى «`2`» «`round`» فۇنكىسىيەسىگە يوللىنىدۇ، بۇ ئەمەلىي جەھەتتە «`round(5.57668, 2)`» غا تەڭ بولىدۇ. بۇ جەريان «`circle_areas`» تىزىمىنىڭ ئاخىرىغىچە داۋام قىلىدۇ.


سىز «نمىشقا» دەپ ئويلىنىۋاتقىنىڭىزغا ئىشىنىمەن: «ئەگەر بىرلەشتۈرۈلگەن ئىككىنچى تىزىم، بىرىنچى تىزىمنىڭ ئۇزۇنلۇقىدىن ئاز ياكى كۆپ بولسا قانداق بولىدۇ؟ باشقاچە ئېيتقاندا، ئەگەر يۇقىرىقى فۇنكىسىيەدە ئىككىنچى تىزىم سۈپىتىدە «`range(1, 3)`» ياكى «`range(1, 9999)`» نى يوللىسام قانداق بولىدۇ؟»

جاۋاب ئاددىي: «ھېچ نەرسە!» — بولسا، بۇ توغرا ئەمەس. «ھېچ نەرسە» دېگەن گەپ «`map()`» فۇنكىسىيەسى ھېچقانداق خاتالىق چىقارمايدۇ، دېگەن مەنىدە. ئۇ پەقەت ئىككىنچى پارامېتىر (تۈزۈلگەن تىزىمنىڭ ئىككىنچى بۆلىكى) توشقانچە تەكرارلايدۇ، ئەمما ئۇنىڭدىن كېيىن ئۇ توختايدۇ ۋە شۇغىلدىكى نەتىجىنى قايتۇرىدۇ.


مەسىلەن، ئەگەر سىز «result = list(map(round, circle_areas, range(1, 3)))» نى باھالاسىڭىز، «circle_areas» بىلەن «range(1, 3)» نىڭ ئۇزۇنلۇقى پەرقلىق بولسىمۇ، Python ھېچقانداق خاتالىق چىقارمايدۇ.

بۇنىڭ ئورنىغا Python نېمىش قىلىدۇ؟ ئۇ «circle_areas» نىڭ تۇنجى ئېلېمېنتىنى ۋە «range(1,3)» نىڭ تۇنجى ئېلېمېنتىنى ئېلىپ «round» فۇنكىسىيىسىگە يوللايدۇ. «round» بۇنى ھېسابلاپ، نەتىجىنى ساقلايدۇ.

كېيىن ئۇ ئىككىنچى قېتىملىق تەكرارلاشقا ئۆتىدۇ: «circle_areas» نىڭ ئىككىنچى ئېلېمېنتى ۋە «range(1,3)» نىڭ ئىككىنچى ئېلېمېنتى «round» غا يوللىنىدۇ، «round» نەتىجىنى يەنە ساقلايدۇ.

ئاندىن ئۈچۈنچى قېتىملىق تەكرارلاشقا كەلگەندە (چۈنكى «circle_areas» تا ئۈچۈنچى ئېلېمېنت بار)، Python بۇ ئۈچۈنچى ئېلېمېنتنى ئېلىدۇ، ئەمما «range(1,3)» تا ئۈچۈنچى ئېلېمېنت يوق بولغانلىقتىن، Python پەقەت توختايدۇ ۋە شۇغىچە ئېلىنغان نەتىجىلەرنى قايتۇرىدۇ.

بۇ ئەھۋالدا نەتىجە «[3.6, 5.58]» بولىدۇ.

مەزكۇر كودنى Python دا سىناپ كۆرۈڭ:

    # Python 3

    circle_areas = [3.56773, 5.57668, 4.00914, 56.24241, 9.01344, 32.00013]

    result = list(map(round, circle_areas, range(1, 3)))

    print(result)


ئەگەر «`circle_areas`» نىڭ ئۇزۇنلۇقى ئىككىنچى تىزىمدىن ئاز بولسىمۇ، ئۇنداقتا ئوخشاشلا نەرسە كۆرۈلىدۇ. Python ئىككى تىزىمنىڭ بىرىدىن كېيىنكى ئېلېمېنتىنى تاپالمىغان ۋاقتى توختايدۇ، ھېچقانداق خاتالىق چىقمىيدۇ.


«map()» فۇنكىسىيەسى ھەققىدە بىلىملىرىمىزنى مۇقىملاشتۇرۇش ئۈچۈن، بىز ئۇنى ئىشلىتىپ ئۆزىڭلارنىڭ «zip()» فۇنكىسىيىسىنى قۇرۇپ چىقىمىز.

«zip()» فۇنكىسىيەسى — بىر قانچە تىزىم (iterables) نى قوبۇل قىلىپ، ئۇلارنىڭ ھەر بىر ئورنىدىكى ئېلېمېنتلىرىدىن بىر تۇتاش tuple قۇرۇپ چىقىدىغان فۇنكىسىيە. «map()» فۇنكىسىيەسىگە ئوخشاش، Python 3 تا «zip()» بولسا بىر generator (يېتىلگەن ئوبيېكت) قايتۇرىدۇ، بۇنى «list» دېگەن بويىچە تىزىمگە ئايلاندۇرغىلى بولىدۇ.

تۆۋەندىكى Python ئىزاھلاش مۇھىتى (interpreter) نى ئىشلىتىپ، «zip()» قانداق ئىشләйدىغىنىنى چۈشەنىۋېلىڭ، كېيىن «map()» ئارقىلىق ئۆز «zip» فۇنكىسىيىسىمىزنى ياسىيمىز:

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(zip(my_strings, my_numbers))
    
    print(results)

يەنىمۇ ئىلگىرلىگەن ھالدا، تەخمىن قىلايلى: ئەگەر «my_strings» ۋە «my_numbers» نىڭ ئۇزۇنلۇقى بىر-بىرىگە ماس كەلمىسىچە نېمە بولىدۇ؟ تەخمىن قىلالامدىڭىزمۇ؟ يوقمۇ؟ ئۇنداقتا سىناپ كۆرۈڭ! ئۇلارنىڭ بىرىنىڭ ئۇزۇنلۇقىنى ئۆزگەرتىپ باققانمۇ؟

ئاندىن، ئۆزىمىزنىڭ «zip()» فۇنكىسىيىسىنى قۇرايلى!

    # Python 3

    my_strings = ['a', 'b', 'c', 'd', 'e']
    my_numbers = [1, 2, 3, 4, 5]

    results = list(map(lambda x, y: (x, y), my_strings, my_numbers))

    print(results)

بۇنىڭغا قارىڭ! نەتىجە «`zip`» بىلەن ئوخشاش چىقتى.


سىز دىققەت قىلدىڭىزمۇ، مەن ھەتتا «def my_function()» دىگەن ئەڭ ئەنئەنىۋى ئۇسۇل بىلەن فۇنكىسىيە ياساشقا مۇھتاج بولمىدىم؟ بۇ «map()» نىڭ ۋە Python نىڭ قانچىلىك يېڭىلىققا ياراتقانلىقىنىڭ دەلىلى! مەن پەقەت «lambda» فۇنكىسىيىسىنى ئىشلەتتىم. بۇنىڭ مەنىسى، «def function_name()» ئارقىلىق فۇنكىسىيە تەييارلاشقا بولمايدۇ دېگەنلىك ئەمەس؛ بولىدۇ، ئەمما مەن ئازراق كود يېزىشنى (ياڭىچە، «Pythonic» ئۇسلۇبتا) تاللىدىم.

«map» ھەققىدە شۇ قەدەر بولسۇن. ھازىر بولسا «filter()» غا ئۆتىمىز!

#### سۈزگۈچ
«map()» فۇنكىسىيەسى تىزىمدىكى ھەر بىر ئېلېمېنتنى بىر فۇنكىسىيە ئارقىلىق ئۆتكۈزۈپ، بارلىق ئېلېمېنتلەرنىڭ فۇنكىسىيە ئارقىلىق ئۆتكەن نەتىجىسىنى قايتۇرۇدىغان بولسا، «filter()» ئەڭ ئاۋۋال فۇنكىسىيەنىڭ نەتىجىسىنىڭ (True ياكى False) بولىشىنى تەلەپ قىلىدۇ. ئۇ تىزىمدىكى ھەر بىر ئېلېمېنتنى فۇنكىسىيە ئارقىلىق ئۆتكۈزۈپ، نەتىجىسى «True» بولغانلارنى قالدۇرۇپ، «False» بولغانلارنى «filter» قىلىپ چىقىرىدۇ. ئۇنىڭ تۈزۈلمىسى تۆۋەندىكىچە:

```filter(func, iterable)```

`` Filter () `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` `` ``

1. "خەرىتە ()" گە ئوخشىمايدىغىنى ، پەقەت بىرلا تەكرارلاش تەلەپ قىلىنىدۇ.
2. «فۇنكسىيە» نىڭ ئىككىلىك سان قايتۇرۇشنى تەلەپ قىلىنىدۇ. ئەگەر ئۇنداق بولمىسا ، "سۈزگۈچ" پەقەت ئۇنىڭغا قايتۇرۇلغان "قايتىلانما" نى قايتۇرىدۇ. ئۇنىڭدىن باشقا ، پەقەت بىرلا تەكرارلىنىشقا ئېھتىياجلىق بولغاچقا ، «فۇنكسىيە» گە پەقەت بىرلا مىقدار بېرىلىشى كېرەك.
3. مېنىڭ دېمەكچى بولغىنىم ، ئۇ دەل شۇ يەردە - «سۈزگۈچ».

بەزى مىساللارنى كۆرۈپ باقايلى

تۆۋەندىكىسى خىمىيىلىك ئىمتىھاندا 10 ئوقۇغۇچىنىڭ ئېرىشكەن نومۇرى (`` iterable``). «` سۈزگۈچ »ئارقىلىق 75 دىن ئارتۇق نومۇر بىلەن ئۆتكەنلەرنى سۈزۈپ چىقايلى.

    # Python 3
    scores = [66, 90, 68, 59, 76, 60, 88, 74, 81, 65]

    def is_A_student(score):
        return score > 75

    over_75 = list(filter(is_A_student, scores))

    print(over_75)

كېيىنكى مىسال پالېندروم تەكشۈرگۈچ بولىدۇ. «پەلەمپەيسىمان سۆز» بىر سۆز ، ئىبارە ياكى تەرتىپ بولۇپ ، ئالدى تەرەپكە ئوخشاش ئوقۇلىدۇ. گۇمانلىق پالېندرومنىڭ بىر توپى (`` iterable```) دىن palindromes بولغان سۆزلەرنى سۈزۈپ چىقايلى.

    # Python 3
    dromes = ("demigod", "rewire", "madam", "freer", "anutforajaroftuna", "kiosk")

    palindromes = list(filter(lambda word: word == word[::-1], dromes))

    print(palindromes)

Which should output `` ['madam', 'anutforajaroftuna'] ``. 

چىرايلىق رەتلىك ھە؟ ئاخىرىدا ، `` `` (`` `)

#### ئازايتىش
«reduce» فۇنكىسىيەسى ئىككى پارامېتىرلىك بىر فۇنكىسىيەنى تىزىمدىكى ئېلېمېنتلارغا بىر-بىر قىلىپ ئىلگىرىلەشلىك (كومۇلاتىپ) شەكىلدە قوللايدۇ، ھەمدە تاللاشچە بىر باشلانغۇچ پارامېتىر بىلەن باشلاشقا بولىدۇ. ئۇنىڭ تۈزۈلمىسى تۆۋەندىكىچە:

```reduce(func, iterable[, initial])```

`بۇ يەردە «func» — تىزىمدىكى ھەر بىر ئېلېمېنتقا كومۇلاتىپ قوللىنىلىدىغان فۇنكىسىيە، «initial» بولسا تاللاشچە قىممەت بولۇپ، ھېسابلاش جەريانىدا تىزىم ئېلېمېنتلىرىدىن بۇرۇن قويۇلىدۇ ۋە تىزىم بوش بولغاندا دەفتەر قىممەت (default) رولىنى ئوينايدۇ.

«reduce()» ھەققىدە تۆۋەندىكىلەرنى دىققەت قىلىش كېرەك:
1. «func» ئىككى پارامېتىرنى تەلەپ قىلىدۇ، بۇنىڭدىن بىرى تىزىمدىكى تۇنجى ئېلېمېنت (ئەگەر «initial» بېرىلمىگەن بولسا)، يەنە بىرى تىزىمدىكى ئىككىنچى ئېلېمېنت بولىدۇ. ئەگەر «initial» بېرىلگەن بولسا، ئۇ «func» نىڭ تۇنجى پارامېتىرىغا ئايلانىدۇ، تىزىمدىكى تۇنجى ئېلېمېنت بولسا ئىككىنچى پارامېتىرغا ئايلانىدۇ.

2. «reduce» تىزىمنى بىرلا قىممەتكە «قىسقىرتىدۇ» (بۇنى بىلىمەن، كەچۈرۈڭ).

ئادەتتىكىگە ئوخشاش ، بەزى مىساللارنى كۆرۈپ باقايلى.

ئۆزىمىزنىڭ Python نىڭ ئىچىگە قاچىلانغان `` sum () `` فۇنكسىيەسىنى ئۆزىمىز قۇرايلى. `` Sum () `` فۇنكسىيەسى ئۇنىڭغا تەكرارلانغان بارلىق تۈرلەرنىڭ يىغىندىسىنى قايتۇرىدۇ.


    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers)
    print(result)


نەتىجە ، سىز ئويلىغاندەك `` 68``.

ئۇنداقتا ، نېمە ئىش بولدى؟

ئەڭ ئادەتتىكىدەك، بۇنىڭمۇ ھەممىسى تەكرارلاشقا دائىر: «reduce» بىرىنچى ۋە ئىككىنچى «numbers» تىزىمدىكى ئېلېمېنتلارنى ئېلىپ، ئۇلارنى custom\_sum فۇنكىسىيەسىگە ئاپىرىدۇ. custom\_sum ئۇلارنىڭ يىغىندىسىنى ھېسابلاپ، نەتىجىنى «reduce» غا قايتۇرىدۇ. «reduce» بۇ نەتىجىنى custom\_sum نىڭ بىرىنچى پارامېتىرىغا ئايلاندۇرىپ، كېيىنكى (ئۈچۈنچى) «numbers» ئېلېمېنتىنى ئىككىنچى پارامېتىر قىلىپ custom\_sum غا يوللايدۇ. بۇ جەريان «numbers» تاماملانغانچە داۋام قىلىدۇ.


ئىختىيارىي `` initial`` قىممىتىنى ئىشلەتكەندە نېمە ئىش يۈز بېرىدىغانلىقىنى كۆرۈپ باقايلى.


    # Python 3
    from functools import reduce

    numbers = [3, 4, 6, 9, 34, 12]

    def custom_sum(first, second):
        return first + second

    result = reduce(custom_sum, numbers, 10)
    print(result)


كۇتۇلغانچە، نەتىجە 78 بولىدۇ، چۈنكى «reduce» دەسلەپتە 10 نى custom\_sum نىڭ تۇنجى پارامېتىرىغا ئىشلىتىدۇ.


بۇلارنىڭ ھەممىسى Python نىڭ خەرىتىسى ، ئازايتىش ۋە سۈزگۈچكە مۇناسىۋەتلىك. تۆۋەندىكى ئىقتىدارلارنى ئىشلىتىپ سىناپ بېقىڭ ، ھەر بىر ئىقتىدارغا بولغان چۈشەنچىڭىزنى چوڭقۇرلاشتۇرۇڭ.

كۆنۈكمە
--------
بۇ مەشىقتە بۇزۇلغان كودنى ئوڭشاش ئۈچۈن «خەرىتە» ، «سۈزگۈچ» ۋە «ئازايتىش» نىڭ ھەر بىرىنى ئىشلىتىسىز. 

Tutorial Code
-------------
from functools import reduce 

# Use map to print the square of each numbers rounded
# to three decimal places
my_floats = [4.35, 6.09, 3.25, 9.77, 2.16, 8.88, 4.59]

# Use filter to print only the names that are less than 
# or equal to seven letters
my_names = ["olumide", "akinremi", "josiah", "temidayo", "omoseun"]

# Use reduce to print the product of these numbers
my_numbers = [4, 6, 9, 23, 5]

# Fix all three respectively.
map_result = list(map(lambda x: x, my_floats))
filter_result = list(filter(lambda name: name, my_names, my_names))
reduce_result = reduce(lambda num1, num2: num1 * num2, my_numbers, 0)

print(map_result)
print(filter_result)
print(reduce_result)

Expected Output
---------------
test_output_contains("[18.922, 37.088, 10.562, 95.453, 4.666, 78.854, 21.068]")
test_output_contains("['olumide', 'josiah', 'omoseun']")
test_output_contains("24840")
success_msg("Congrats! Nice work.")

Solution
--------
#### Map
from functools import reduce 

my_floats = [4.35, 6.09, 3.25, 9.77, 2.16, 8.88, 4.59]
my_names = ["olumide", "akinremi", "josiah", "temidayo", "omoseun"]
my_numbers = [4, 6, 9, 23, 5]

map_result = list(map(lambda x: round(x ** 2, 3), my_floats))
filter_result = list(filter(lambda name: len(name) <= 7, my_names))
reduce_result = reduce(lambda num1, num2: num1 * num2, my_numbers)

print(map_result)
print(filter_result)
print(reduce_result)
