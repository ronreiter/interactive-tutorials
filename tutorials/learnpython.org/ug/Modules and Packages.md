Tutorial
--------

پروگرامما تۈزۈشتە ، مودۇل مەلۇم ئىقتىدارغا ئىگە يۇمشاق دېتال. 
مەسىلەن ، تىك-تاك توپ ئويۇنى قۇرغاندا ، بىر مودۇل ئويۇن لوگىكىسىغا مەسئۇل بولۇشى مۇمكىن ، ۋە 
باشقا بىر بۆلەك ئويۇننى ئېكرانغا سىزىدۇ. ھەر بىر بۆلەك تەھرىرلەشكە بولىدىغان ئوخشىمىغان
ھۆججەتىن تەركىپ تاپىدۇ.

### يېزىش مودۇلى

Python دىكى مودۇللار پەقەت .py كېڭەيتىلگەن نامىدىكى Python ھۆججىتى. بۆلەكنىڭ ئىسمى ھۆججەت ئىسمى بىلەن ئوخشاش.
Python مودۇلىدا ئېنىقلانغان ۋە يولغا قويۇلغان بىر يۈرۈش ئىقتىدار ، دەرىجە ياكى ئۆزگەرگۈچى مىقدار بولىدۇ. 
يۇقىرىدىكى مىسال ئىككى ھۆججەتنى ئۆز ئىچىگە ئالىدۇ:

mygame /

- mygame / game.py

- mygame / draw.py
    
 
Python ھۆججتى بۇ يەردە  `game.py` ئويۇننى ئىجرا قىلىدۇ. ئۇ «draw.py» ھۆججىتىدىن «draw_game» فۇنكىسىيىنى ئىشلىتىدۇ ،
ياكى باشقىچە قىلىپ ئېيتقاندا ، ئويۇننى ئېكراندا سىزىشنىڭ لوگىكىسىنى ئىجرا قىلىدىغان «سىزىش» مودۇلى.

بۆلەكلەر «ئىمپورت» بۇيرۇقىنى ئىشلىتىپ باشقا مودۇللاردىن ئىمپورتلىنىدۇ. بۇ مىسالدا `game.py` ھۆججىتى مۇنداق بولۇشى مۇمكىن:

    # game.py
    # import the draw module
    import draw
    
    def play_game():
        ...
    
    def main():
        result = play_game()
        draw.draw_game(result)
        
    # this means that if this script is executed, then 
    # main() will be executed
    if __name__ == '__main__':
        main()

«سىزىش» مودۇلى مۇنداق بولۇشى مۇمكىن:

    # draw.py
    
    def draw_game():
        ...

    def clear_screen(screen):
        ...

بۇ مىسالدا ، «ئويۇن» مودۇلى «سىزىش» مودۇلىنى ئەكىرىدۇ ، ئۇ ئىجرا قىلىنغان فۇنكىسىيەلەرنى ئىشلىتەلەيدۇ
بۇ بۆلەكتە. `Main` فۇنكسىيەسى يەرلىك ئويۇن` play_game` نى ئىشلىتىپ ئويۇننى باشقۇرىدۇ 
«draw_game» دەپ ئاتىلىدىغان «سىزىش» مودۇلىدا ئىجرا قىلىنغان فۇنكىسىيلەرنى ئىشلىتىپ ئويۇننىڭ نەتىجىسىنى سىزىدۇ.
«سىزىش» مودۇلىدىكى «draw_game» فۇنكىسىيەسىنى ئىشلىتىش ئۈچۈن ، فۇنكسىيەنىڭ قايسى مودۇلدا ئىكەنلىكىنى ئېنىقلىشىمىز كېرەك، چىكىت ئەمىلىنى ئىشلىتىپ.
چ «ئويۇن» مودۇلىدىكى «draw_game» ئىقتىدارىنى پايدىلىنىش ئۈچۈن ،
بىز «سىزىش» مودۇلىنى ئەكىرىپ ئاندىن «()draw.draw_game» دەپ چاقىرىشىمىز كېرەك. 

«ئەكىرىش سىزىش» كۆرسەتمىسى ئىجرا بولغاندا ، Python تەرجىمانى مۇندەرىجە ئىچىدىكى مۇندەرىجە نامى ۋە `.py` قوشۇمچىسى بىلەن ھۆججەتنى ئىزدەيدۇ. بۇ ئەھۋالدا ئۇ «draw.py» نى ئىزدەيدۇ. ئەگەر تېپىلسا ، ئىمپورت قىلىنىدۇ. ئەگەر تېپىلمىسا ، ئىچىگە ئورۇنلاشتۇرۇلغان مودۇللارنى داۋاملىق ئىزدەيدۇ.

مودۇل ئەكىرىگەندە `.pyc` ھۆججىتىنىڭ قۇرۇلغانلىقىغا دىققەت قىلغان بولۇشىڭىز مۇمكىن. بۇ تۈزۈلگەن Python ھۆججىتى. 
Python ھۆججەتلەرنى Python bytecode غا توپلايدۇ ، بۇنداق بولغاندا ھەر قېتىم مودۇللار يۈكلەنگەندە ھۆججەتلەرنى تەھلىل قىلىشقا بولمايدۇ. ئەگەر .pyc` ھۆججىتى بولسا ، .py ھۆججىتىنىڭ ئورنىغا يۈكلىنىدۇ. بۇ جەريان ئىشلەتكۈچىگە ئوچۇق.

### نۆۋەتتىكى ئىسىم بوشلۇقىغا مودۇل ئوبيېكتلىرىنى ئەكىرىش

ئىسىم بوشلۇقى ھەر بىر جىسىمنىڭ ئىسمى قويۇلغان ۋە Python دا زىيارەت قىلغىلى بولىدىغان سىستېما. «From_game» فۇنكسىيەسىنى «from» بۇيرۇقىنى ئىشلىتىپ ئاساسلىق قوليازمىنىڭ ئىسىم بوشلۇقىغا ئەكىرىمىز.

    # game.py
    # import the draw module
    from draw import draw_game
    
    def main():
        result = play_game()
        draw_game(result)


سىز بۇ مىسالدا مودۇلنىڭ نامىنىڭ «draw_game» نىڭ ئالدىدا ئەمەسلىكىنى بايقىغان بولۇشىڭىز مۇمكىن ، چۈنكى بىز «ئىمپورت» بۇيرۇقىنى ئىشلىتىپ مودۇل نامىنى بەلگىلىدۇق.

بۇ ئىزاھاتنىڭ ئەۋزەللىكى شۇكى ، مودۇلنى قايتا-قايتا پايدىلىنىشىڭىزنىڭ ھاجىتى يوق. قانداقلا بولمىسۇن ، ئىسىم بوشلۇقى ئوخشاش ئىسىمدىكى ئىككى جىسىمغا ئىگە بولالمايدۇ ، شۇڭا «ئىمپورت» بۇيرۇقى ئىسىم بوشلۇقىدىكى مەۋجۇت ئوبيېكتنىڭ ئورنىنى ئېلىشى مۇمكىن.


### بارلىق ئوبيېكتلارنى مودۇلدىن ئەكىرىش

سىز «ئىمپورت *» بۇيرۇقىنى ئىشلىتىپ مودۇلدىكى بارلىق ئوبيېكتلارنى ئەكىرىسىز:

    # game.py
    # import the draw module
    from draw import *
    
    def main():
        result = play_game()
        draw_game(result)

بۇ بەلكىم سەل خەتەرلىك بولۇشى مۇمكىن ، چۈنكى مودۇلدىكى ئۆزگىرىشلەر ئۇنى ئىمپورت قىلىدىغان مودۇلغا تەسىر قىلىشى مۇمكىن ، ئەمما ئۇ شۇنداق 
قىسقا ، ھەمدە سىز مودۇلدىن ئەۋەتمەكچى بولغان ھەر بىر ئوبيېكتنى بەلگىلىشىڭىزنى تەلەپ قىلمايدۇ.


### ئىختىيارى ئىمپورت ئىسمى

مودۇللار سىز خالىغان ئىسىم ئاستىدا يۈكلىنىشى مۇمكىن. بۇ مودۇلنى قالغان كودلاردا ئوخشاش ئىسىمدا ئىشلىتىش ئۈچۈن  شەرتلىك ئىمپورت قىلىشقا پايدىلىق.

مەسىلەن ، ئەگەر سىزدە ئوخشىمىغان ئىسىملار بىلەن ئىككى «سىزىش» مودۇلى بولسا ، تۆۋەندىكى ئىشلارنى قىلالايسىز:
 

    # game.py
    # import the draw module
    if visual_mode:
        # in visual mode, we draw using graphics
        import draw_visual as draw
    else:
        # in textual mode, we print out text
        import draw_textual as draw
    
    def main():
        result = play_game()
        # this can either be visual or textual depending on visual_mode
        draw.draw_game(result)


### مودۇل دەسلەپلەشتۈرۈش

تۇنجى قېتىم ئىجرا بولۇۋاتقان Python قوليازمىسىغا مودۇل يۈكلەنگەندە ، ئۇ مودۇلدىكى كودنى بىر قېتىم ئىجرا قىلىش ئارقىلىق باشلىنىدۇ. ئەگەر كودىڭىزدىكى باشقا بىر مودۇل ئوخشاش مودۇلنى قايتا ئىمپورتلىسا ، ئۇ قايتا يۈكلەنمەيدۇ ، شۇڭا مودۇل ئىچىدىكى يەرلىك ئۆزگەرگۈچى مىقدارلار «يەككىلىك» رولىنى ئوينايدۇ ، يەنى ئۇلار پەقەت بىرلا قېتىم دەسلەپلەنگەن.

ئاندىن بۇنى ئىشلىتىپ ئوبيېكتلارنى قوزغىتالايسىز. 
مەسىلەن:


    # draw.py
    
    def draw_game():
        # when clearing the screen we can use the main screen object initialized in this module
        clear_screen(main_screen)
        ...

    def clear_screen(screen):
        ...
        
    class Screen():
        ...

    # initialize main_screen as a singleton
    main_screen = Screen()


### مودۇل يۈكلەش يولىنى كېڭەيتىش

Python تەرجىمانىغا مودۇلنى نەدىن ئىزدەشنى ئېيتىشنىڭ بىر قانچە خىل ئۇسۇلى بار
سۈكۈتتىكى يەرلىك مۇندەرىجە ۋە ئىچىگە ئورۇنلاشتۇرۇلغان بۆلەكلەر. سىز مۇھىت ئۆزگەرگۈچى `PYTHONPATH` نى ئىشلىتىپ قوشۇمچە مۇندەرىجىلەرنى بەلگىلىسىڭىز بولىدۇ.

    PYTHONPATH=/foo python game.py

ببۇ `game.py` نى ئىجرا قىلىدۇ ، ھەمدە قوليازما ھۆججىتىنى` foo` مۇندەرىجىسىدىن شۇنداقلا يەرلىك مۇندەرىجىدىن يۈكلەيدۇ.


سىز يەنە `sys.path.append` ئىقتىدارىنى ئىشلىتەلەيسىز. ئۇنى «Import» بۇيرۇقىنى ئىجرا قىلىشتىن بۇرۇن ئىجرا قىلىڭ:

    sys.path.append("/foo")

ھازىر «foo» مۇندەرىجىسى مودۇل ئىزدەيدىغان يوللار تىزىملىكىگە قوشۇلدى.


### ئىچىگە ئورۇنلاشتۇرۇلغان مودۇل ئۈستىدە ئىزدىنىش

Python ئۆلچەملىك كۇتۇپخانىسىدىكى ئىچكى بۆلەكلەرنىڭ تولۇق تىزىملىكىنى كۆرۈڭ (https://docs.python.org/3/library/).

Python دىكى مودۇلنى تەكشۈرگەندە - dir ۋە help فۇنكسىيەلىرى  ئىنتايىن مۇھىم ھەم پايدىلىق.

URL دىن ئوقۇش سانلىق مەلۇماتلىرىنى قۇرالايدىغان «urllib» مودۇلىنى ئەكىرىش ئۈچۈن ، بىز مودۇلنى «ئەكىرىمىز»:

    # import the library
    import urllib

    # use it
    urllib.urlopen(...)
    
بىز «dir» فۇنكسىيەسىنى ئىشلىتىپ ھەر بىر بۆلەكتە قايسى ئىقتىدارلارنىڭ ئىجرا قىلىنىدىغانلىقىنى ئىزدەيمىز:

    >>> import urllib
    >>> dir(urllib)
    ['ContentTooShortError', 'FancyURLopener', 'MAXFTPCACHE', 'URLopener', '__all__', '__builtins__', 
    '__doc__', '__file__', '__name__', '__package__', '__version__', '_ftperrors', '_get_proxies', 
    '_get_proxy_settings', '_have_ssl', '_hexdig', '_hextochr', '_hostprog', '_is_unicode', '_localhost', 
    '_noheaders', '_nportprog', '_passwdprog', '_portprog', '_queryprog', '_safe_map', '_safe_quoters', 
    '_tagprog', '_thishost', '_typeprog', '_urlopener', '_userprog', '_valueprog', 'addbase', 'addclosehook', 
    'addinfo', 'addinfourl', 'always_safe', 'basejoin', 'c', 'ftpcache', 'ftperrors', 'ftpwrapper', 'getproxies', 
    'getproxies_environment', 'getproxies_macosx_sysconf', 'i', 'localhost', 'main', 'noheaders', 'os', 
    'pathname2url', 'proxy_bypass', 'proxy_bypass_environment', 'proxy_bypass_macosx_sysconf', 'quote', 
    'quote_plus', 'reporthook', 'socket', 'splitattr', 'splithost', 'splitnport', 'splitpasswd', 'splitport', 
    'splitquery', 'splittag', 'splittype', 'splituser', 'splitvalue', 'ssl', 'string', 'sys', 'test', 'test1', 
    'thishost', 'time', 'toBytes', 'unquote', 'unquote_plus', 'unwrap', 'url2pathname', 'urlcleanup', 'urlencode', 
    'urlopen', 'urlretrieve']

بىز ئىشلەتمەكچى بولغان بۆلەكتىكى ئىقتىدارنى تاپقىنىمىزدا ، Python تەرجىمانى ئارقىلىق «ياردەم» ئىقتىدارى بىلەن بۇ توغرىلىق تېخىمۇ كۆپ ئۇچۇرلارنى ئوقۇيالايمىز:

    help(urllib.urlopen)

### بوغچا يېزىش

بوغچا بىر نەچچە بوغچا ۋە مودۇلنى ئۆز ئىچىگە ئالغان ئىسىم بوشلۇقى. ئۇلار پەقەت مۇندەرىجە ، ئەمما بەزى تەلەپلەر بار.

Python دىكى ھەر بىر بولاق مۇندەرىجە بولۇپ ، **چۇقۇم ** `__init __. Py` دەپ ئاتىلىدىغان ئالاھىدە ھۆججەتنى ئۆز ئىچىگە ئالىدۇ. قۇرۇق بولالايدىغان بۇ ھۆججەت ئۇنىڭ ئىچىدىكى مۇندەرىجىنىڭ Python بولىقى ئىكەنلىكىنى كۆرسىتىدۇ. بۇنداق بولغاندا ئۇنى مودۇلغا ئوخشاش ئىمپورت قىلغىلى بولىدۇ.

ئەگەر بوغچا نامىغا بەلگە قويغان «foo» دەپ ئاتىلىدىغان مۇندەرىجە قۇرساق ، ئۇنىڭ ئىچىدە مودۇل قۇرالايمىز 
بوغچا `bar` دەپ ئاتىلىدۇ. ئاندىن `foo` مۇندەرىجىسىگە` __init __. Py` ھۆججىتىنى قوشىمىز.

مودۇل `bar` نى ئىشلىتىش ئۈچۈن ئۇنى ئىككى خىل ئۇسۇلدا ئەكىرىمىز:

    import foo.bar

ياكى:

    from foo import bar

يۇقىرىدىكى بىرىنچى مىسالدا ، بىز «bar» مودۇلىغا كىرگەندە «foo» ئالدى قوشۇلغۇچىسىنى ئىشلىتىشىمىز كېرەك. ئىككىنچى مىسالدا ، بىز ئۇنداق قىلمايمىز ، چۈنكى بىز مودۇلنى مودۇلىمىزنىڭ ئىسىم بوشلۇقىغا ئەكىرىپ قويدۇق.

«__Init __. Py`» ھۆججىتى يەنە «__all__» ئۆزگەرگۈچى مىقدارنى بېسىپ ئۆتۈپ ، باشقا مودۇللارنىڭ ئىچكى قىسمىنى ساقلاپ قېلىش بىلەن بىرگە ، قايسى مودۇللارنىڭ API سۈپىتىدە ئېكسپورت قىلىنىدىغانلىقىنى قارار قىلالايدۇ.

    __init__.py:

    __all__ = ["bar"]

كۆنۈكمە
--------

بۇ مەشىقتە ، «find» سۆزىنى ئۆز ئىچىگە ئالغان «re» مودۇلىدىكى بارلىق ئىقتىدارلارنىڭ ئېلىپبە تەرتىپى بويىچە رەتلەنگەن تىزىملىكىنى بېسىڭ.

Tutorial Code
-------------

import re

# Your code goes here
find_members = []

Expected Output
---------------

test_object('find_members')
success_msg('Great work!')

Solution
--------

import re

# Your code goes here
find_members = []
for member in dir(re):
    if "find" in member:
        find_members.append(member)

print(sorted(find_members))
